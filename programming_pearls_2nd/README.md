# 珠玉のプログラミング 第二版

## コラム1 真珠貝を開いて
* ソートしたいというだけでも、状況によって適切なアルゴリズムは違う
	* → 1MBしかメモリがない、データは最大で10^7個(10M個)
	* → どういうことかというと、電話番号をソートしたい
* 解決策
	* X 単純にソートするだけ
	* O ビット列の各ビットに有無を記録する
		* ! 集合と似たような扱いになりそう
* 分かること
	* 正しく問題を定義することの大切さ
		* 状況や値の範囲などから今回ビットマップを使うアイデアを思いつけた。
	* ビット列の空間効率
		* データの密度が高いこと（1..100, 1000..2000みたいな飛び飛びのデータには効率が良くなさそう）
		* 重複がないこと
	* 多パスのアルゴリズム
	* 実行時間と使用メモリのトレードオフ
		* だいたいトレードオフになる場合が多い
		* ただ筆者の経験上は、「省メモリであれば実行時間も短くなる」とのこと
	* 単純な設計
		* 安全、堅牢、効率的、制作、高い保守性につながる
	* プログラムデザインの段階
* まとめ
	* さっと「プログラムの性質や機能を決める」方法を眺めた

<!-- {{{ -->

### 問題1 さっきの問題、セットやソートがあるならどう実装する？
* 解答
	* <./1-1a.rb>
	* <./1-1b.rb>

### 問題2 and, or, shiftなどのビット演算を使って、ビットの配列みたいなのを作ってみよう
* 解答
	* <./1-2.rb>

### 問題3 実行時間を図ってみよう
後でやりたい

### 問題4 入力に使うデータをどうやって生成しよう？
1〜kまでの整数をそのまま使うというのも手だが、それだとランダムなデータに比べて、バブルソートとかは一瞬で終わってしまって、比較しづらい。

* 解答
	* 答えを見た
	* <./1-4.rb>

### 問題5 もしメモリ1MBしか使えなかったら？
単純に考えたら、2回読み返すのが良さそう。
もう1回ディスクから読み直しても、20秒程度であればアリなんじゃないか。
よく読み返したら、「問題5で2パスのプログラムを考える」って書かれている。

あるいはより遅いが、1MBにメモリを収められるアルゴリズムに書き換えるのが良いのか。

### 問題6 もし整数が重複して現れるなら...？
10回までということなので、`log2(10) = 約3.32`で4bitあれば回数をカウントできる。
空間効率を高めるなら、4bitで表現するのが良さそう。
4bitのデータ型は無いと思うので、自分でカウント処理を実装しなければならず若干面倒だが、空間効率は高くなる。
とはいえ、4倍のデータ量を要するので、1.25 x 4 = 5MBが必要になる。

メモリが少ない場合は、例えば、1MBの場合は5パスのアルゴリズムになるだろう。

一方、使用できるメモリ量が十分にあるなら、単純に1バイト(8bit)単位の配列を作ってしまうのが良さそう。
この場合、使用するメモリ量が10MBになるが、処理自体は単純化できる。

### 問題7 入力値が変だったら？
「事前条件」をチェックする

```
-1
4294967296
2147483648
```

### 問題8 800, 877, 888と無料電話の地域コードが増えてきている
* A. 2パス x 3回？
* B. 問題6の方法を使って、2ビットで表現する

### 問題9 データでかくなると初期化に時間がかかる
```
挿入済リスト = []
ビットマップ = []

値 = if 挿入済リスト.include?(i)
  ビットマップ[i]
else
  ビットマップ[i] = 0
  挿入済リスト << i
end

ビットマップ[i] = 値
```

データの密度が疎でないと、データの使用量が凄まじく多くなる。
Cだととりあえず小さめでmallocしておいて、後でreallocみたいなことをすることになる？
ただreallocでもデータが増えると、コピーが発生したりして遅くなる可能性がある。

### 問題10 電話で注文すると、後で店頭受取できるサービスをやっている店で、どうやって注文を管理するか
ポイントとなりそうなものは、「数日後に」というところ？
~つまり、古いデータはアクセスされる可能性が低い？~
いや、数日後に取りに来るということなので、日付によらずアクセスされる可能性がある。
もし、1日以内に取りに来る人が大半、みたいな統計的な情報があるのであれば、
上からめくって近い日付のものが見つけやすいので、日付順にソートされていると便利かもしれない。

あとコンピュータを使わないデータベースというところ。
注文を記録し、早く索引できるというところをどう紙などで実現するか。
電話帳みたいに本の形になっている必要は別にないということ。

基本的に「電話番号で引く」というところは、変えなくても良いのかもしれない。
というのも、括弧書きの中にほぼ重複がないというのが書かれているので、キーとして良質だと言える。

もし注文の数が十分少なく、地域コードの下の電話番号が十分にランダムとみなせそうならば、
先頭の0〜9番をインデックスとした伝票刺し(針が生えたやつ)を10個並べておくとか？
これならば日時の降順で常にソートされた状態を作ることができる。
ランダムなら0〜9番に均等に分かれそう（同じ客からたくさん注文が来るような場合は除く。しかし数日後に取りに来ないといけないので、そんなにポンポン買うような商品でもないかもしれない）だし、各インデックスごとのシーケンシャルアクセスはそこまで負荷にならなさそう。
めくってすぐに分かるように、日付と電話番号は一番したに書いておく。
この仮定だと、一日100件程度であれば、5日後は各伝票刺しには50枚ぐらい刺さっていることになるため、
量が多すぎると、さばききれない恐れはある。

巻末の答えの例: 電話番号下二桁をインデックスにして、10x10のマスの瓶に入れる

基本的なアイデアは良さそうだけど、先頭の1文字というのが良くなかったらしい。

よく考えたら、アメリカではどうか知らないけれど、
日本だと市外局番 - 市内局番 - 加入者番号ということなので、もし市内局番をインデックスにしてしまうと、
その地域に密着した店舗だと、インデックスとして意味をなさない可能性が高い。
「取りに来てもらう」と言っているので、取りに来られる距離にいる可能性は高そう。

2桁でインデックスを組めば、衝突率がかなり減りそう。

批判的な観点から答えを考えてみると、

* 10x10だと結構場所を取りそう
* 瓶から取り出しづらそうなイメージ

### 問題11
もともと: 40km, 100ドル, 1時間

データの量によっては、1980年代の電話回線等でも良いので、デジタルな通信方法を使っても良いのかもしれない。
数十枚分のCADの図面が入ったメディア？を運送していたということらしい。
どういうメディアを使っていたのかで結構変わってきそうだが、数KB〜数MBぐらい？と見積もっておく。
でかいデータは、流石に当時のコンピュータでも処理できたかどうか怪しいので、これぐらいか。

調べたところ、Lockheed社は戦闘機とか作っている企業なので、データの暗号化等、ちょっと考慮しておきたい情報もありそう。
だが、一旦は通信速度だけで考えるか。

ただ、1980年の初頭となると、通信環境が普及していたとは言えなさそう？

[#技術メモ]
<!-- :: REFERENCES :: -->
[#技術メモ]: ../技術メモ.md
<!-- :: REFERERS :: -->

---
リファラ: 

